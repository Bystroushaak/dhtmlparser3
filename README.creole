Python version of [[https://github.com/Bystroushaak/DHTMLParser|DHTMLParser]]. 
This version is actually much more advanced, D version is kinda unupdated.

= What is it?
DHTMLParser is a lightweight parser created for one purpose - quick and easy picking
of selected tags from DOM.

It can be very useful when you are writing your own API for a page, or a 
checker or you just need to write quick and dirty web scraper.

If you want, you can also create HTML/XML documents more easily than by joining strings.

= How it works?
The module have just one important function - {{{parseString(s)}}}. This function takes
a string and returns a Document Object Model made of linked {{{HTMLElement}}}
objects (see bellow).

When you call {{{.parseString(s)}}}, the string argument is cut into pieces and
then evaluated. Each piece is checked and if it looks like it could be HTML element, then
it is put into {{{HTMLElement}}} object and proper variables are set (self.__istag and so on). 

Every following element is put into {{{.childs}}} list of this element, until proper 
closing element is found by simple stack mechanism.

Elements with parameters are parsed and parameters are extracted into {{{.params}}} 
property.

Result is array of single linked trees (you can make double linke by calling 
{{{dhtmlparser.makeDoubleLinked(dom)}}}), which is then encapsulated in a blank 
HTMLElement container, which holds the whole DOM in its {{{.childs}}} property.

If you want to parse XML and don't want parser to guess nonpair tags from source,
just set global module property {{{NONPAIR_TAGS}}} to blank list.

== Interactive example

{{{
>>> import dhtmlparser as d
>>> dom = d.parseString("""
... <root>
...  <element name="xex" />
... </root>
... """)
>>> print dom
<dhtmlparser.HTMLElement instance at 0x240b320>
>>> dom.getTagName()  # blank, container element
''
}}}

DOM tree now in memory looks like this:

{{{
dom == <dhtmlparser.HTMLElement instance at 0x240b320>
|- .getTagName() == ""
|- .isTag()      == False
|- .params       == ""
|- .openertag    == None
|- .endtag       == None
`- .childs       == [<dhtmlparser.HTMLElement instance at 0x2403b90>, <dhtmlparser.HTMLElement instance at 0x2403ab8>, <dhtmlparser.HTMLElement instance at 0x240b050>, <dhtmlparser.HTMLElement instance at 0x240b248>]
   |
   |- .childs[0]       == <dhtmlparser.HTMLElement instance at 0x2403b90>
   |  |- .getTagName() == "\n"
   |  |- .isTag()      == False
   |  |- .params       == {}
   |  |- .openertag    == None
   |  |- .endtag       == None
   |  `- .childs       == []
   |
   |- .childs[1]         == <dhtmlparser.HTMLElement instance at 0x2403ab8>
   |  |- .getTagName()   == "root"
   |  |- .isTag()        == True
   |  |- .isEndTag()     == False
   |  |- .isOpeningTag() == True
   |  |- .params         == {}
   |  |- .openertag      == None
   |  |- .endtag         == <dhtmlparser.HTMLElement instance at 0x240b050>
   |  `- .childs         == [<dhtmlparser.HTMLElement instance at 0x2403c68>, <dhtmlparser.HTMLElement instance at 0x2403d88>, <dhtmlparser.HTMLElement instance at 0x2403ea8>]
   |     |
   |     |- .childs[0]       == <dhtmlparser.HTMLElement instance at 0x2403c68>
   |     |  |- .getTagName() == '\n '
   |     |  |- .isTag()      == False
   |     |  |- .params       == {}
   |     |  |- .openertag    == None
   |     |  |- .endtag       == None
   |     |  `- .childs       == []
   |     |
   |     |- .childs[1]         == <dhtmlparser.HTMLElement instance at 0x2403d88>
   |     |  |- .getTagName()   == 'element'
   |     |  |- .isTag()        == True
   |     |  |- .isNonPairTag() == True
   |     |  |- .params         == {'name': 'xex'}
   |     |  |- .openertag      == None
   |     |  |- .endtag         == None
   |     |  `- .childs         == []
   |     |
   |     `- .childs[2]       == <dhtmlparser.HTMLElement instance at 0x2403ea8>
   |        |- .getTagName() == '\n'
   |        |- .isTag()      == False
   |        |- .params       == {}
   |        |- .openertag    == None
   |        |- .endtag       == None
   |        `- .childs       == []
   |
   |- .childs[2]       == <dhtmlparser.HTMLElement instance at 0x240b050>
   |  |- .getTagName() == 'root'
   |  |- .isTag()      == True
   |  |- .isEndTag()   == True
   |  |- .params       == {}
   |  |- .openertag    == <dhtmlparser.HTMLElement instance at 0x2403ab8>
   |  |- .endtag       == None
   |  `- .childs       == []
   |
   `- .childs[3]       == <dhtmlparser.HTMLElement instance at 0x240b248>
      |- .getTagName() == '\n'
      |- .isTag()      == False
      |- .params       == {}
      |- .openertag    == None
      |- .endtag       == None
      `- .childs       == []
}}}

In interactive shell, we can easily verify the tree:
{{{
>>> dom.childs[1].getTagName()
'root'
>>> dom.childs[1].childs
[<dhtmlparser.HTMLElement instance at 0x2403c68>, <dhtmlparser.HTMLElement instance at 0x2403d88>, <dhtmlparser.HTMLElement instance at 0x2403ea8>]
}}}

and so on..

Now, let say, that know that there is HTML element named element and we want to 
get him, but we don't know where it is. In that case {{{.find()}}} will help us:

{{{
>>> dom.find("element")
[<dhtmlparser.HTMLElement instance at 0x2403d88>]
}}}

Or when we don't know name of the element, but we know that he has {{{"name"}}} 
parameter set to {{{"xex"}}}:

{{{
>>> dom.find("", fn = lambda x: "name" in x.params and x.params["name"] == "xex")
[<dhtmlparser.HTMLElement instance at 0x2403d88>]
}}}

Or we want only {{{<element>}}} tags with {{{name="xex"}}} parameters:

{{{
>>> dom.find("element", {"name":"xex"})
[<dhtmlparser.HTMLElement instance at 0x2403d88>]
>>> dom.find("element", {"NAME":"xex"})  # parameter names (not values!) are case insensitive
[<dhtmlparser.HTMLElement instance at 0x2403d88>]
}}}


= HTMLElement property/method list
{{{
|
|++ HTMLElement[] childs
|		If the element has children, they are stored in this property.
|
|++ str[str] params
|		If the HTML element has parametres, you will find them here.
|
|++ HTMLElement endtag
|		In case this tag is an Opener (<p> for example), this variable holds
|		a link to the closing element (</p>).
|
|++ HTMLElement openertag
|		Analogous to endtag.
|
|
|
|-- HTMLElement[] find(string tag_name, string[string] params = null, 
|                      function fn = null, case_sensitive = False)
|		Same as findAll, but doesn't returns endtags. You can always get
|		them from .endtag property.
|
|-- HTMLElement[] findAll(string tag_name, string[string] params = null,
|                         function fn = null, case_sensitive = False)
|		One of the most important methods, which handles DOM queries.
|
|		Lets say that you want each link in a page - 'dom.find("a")' will 
|		return an array of links.
|
|		You can also specify parametres or define a lambda function which 
|		will find whatever you want.
|
|-- HTMLElement[] findB(string tag_name, string[string] params = null, 
|                      function fn = null, case_sensitive = False)
|		Same as findAll, but using Breadth-first algorithm 
|		http://en.wikipedia.org/wiki/Breadth-first_search
|
|-- HTMLElement[] findAllB(string tag_name, string[string] params = null,
|                         function fn = null, case_sensitive = False)
|		Same as findAll, but using Breadth-first algorithm 
|		http://en.wikipedia.org/wiki/Breadth-first_search
|
|
|
|-- bool isTag()
|		Returns true if the element is a tag (closed in <>). Comments aren't 
|		tags!
|
|-- bool isOpeningTag()
|		Returns strue if element have .endtag (is closed).
|
|-- bool isEndTag()
|		Returns true if closing tag. 
|
|-- bool isEndTagTo(HTMLElement opener)
|		Returns true if this element is an end tag </tagname> for given 
|		element.
|
|-- bool isNonPairTag()
|		Returns True if HTMLElement is listed nonpair tag table (br for example)
|		or if it ends with / - <br /> for example.
|
|		You can also change state from pair to nonpair if you use this as setter.
|
|-- bool isPairTag()
|		Return True if this is paired tag - <body> .. </body> for example.
|
|-- bool isComment()
|		Returns true if this element is an HTML comment (<!-- -->).
|
|-- bool isAlmostEqual(self, tag_name, params = None, fn = None, 
|                      case_sensitive = False)
|		Compare element with given tagname, params and/or by lambda function.
|
|		Lambda function is same as in .find().
|
|-- str __str__()
|		String representation of this element, same as prettify().
|
|-- str prettify()
|		Returns prettified HTML output with childs (full document).
|
|-- str tagToString(original = False)
|		Returns a string representation if tag, without childs.
|
|		If original == True, returns original string from which element was 
|		parsed, so if you changed something in .params, there will be no 
|		traces of those changes.
|
|-- str getTagName()
|		Tagname - <a href="bla"> returns "a".
|
|-- str getContent()
|		Childs to string.
|
|
|
|-- None replaceWith(HTMLElement el)
|		Replace element. Useful when you don't want change all references to 
|		object.
|
`-- None removeChild(HTMLElement child, bool end_tag_too = true)
		Removes given subelement. Element is specified by reference, not by
		value, so it always removes only one element!

		end_tag_too specifies if endtag shoud be removed too. Default true.
}}}

= Module method list
{{{
|
|-- None makeDoubleLinked(dom)
|	Standard output from dhtmlparser is single-linked tree. This will make it 
|	double-linked.
|
|-- HTMLElement parseString(str)
|	Parse given string and return DOM tree consisting of single linked 
|	HTMLElements.
|
`-- str removeTags(dom)
	Remove all tags from dom, so result should be plaintext.

	dom -- string, HTMLElement or just array of elements.
}}}

= DOM building
If you want to create DOM from HTMLElements, you can use one of theese four constructors:

{{{
HTMLElement()
HTMLElement("<tag>")
HTMLElement("<tag>", {"param":"value"})
HTMLElement("tag", {"param":"value"}, [HTMLElement("<tag1>"), ...])
}}}

Tag or parameter specification parts can be omitted:

{{{
HTMLElement("<root>", [HTMLElement("<tag1>"), ...])
HTMLElement(
	[HTMLElement("<tag1>"), ...]
)
}}}

== Examples

=== Blank element
{{{
>>> from dhtmlparser import HTMLElement 
>>> e = HTMLElement()
>>> e
<dhtmlparser.HTMLElement instance at 0x7fb2b39ca170>
>>> print e

>>> 
}}}

Usually, it is better to use {{{HTMLElement("")}}}.

=== Nonpair tag
	
{{{

>>> e = HTMLElement("<br>")
>>> e.isNonPairTag()
True
>>> e.isOpeningTag()
False
>>> print e
<br>
}}}

Notice, that closing tag is not created this way.

=== Pair tag

{{{
>>> e = HTMLElement("<tag>")
>>> e.isOpeningTag() # this doesn't check if tag actually is paired, just if it looks like opening tag
True
>>> e.isPairTag()    # this does check if element is actually paired
False
>>> e.endtag = HTMLElement("</tag>")
>>> e.isOpeningTag()
True
>>> e.isOpeningTag()
True
>>> print e
<tag></tag>
}}}

In short:

{{{
>>> e = HTMLElement("<tag>")
>>> e.endtag = HTMLElement("</tag>")
}}}

Or you can always use string parsing:

{{{
>>> e = d.parseString("<tag></tag>")
>>> print e
<tag></tag>
}}}

But don't forget, that elements returned from parseString() are encapsulated in blank tag:

{{{
>>> e = d.parseString("<tag></tag>")
>>> e.getTagName()
''
>>> e.childs[0].tagToString()
'<tag>'
>>> e.childs[0].endtag.tagToString() # referenced thru .endtag property
>>> e.childs[1].tagToString() # manually selected entag from childs - don't use this
'</tag>'
'</tag>
}}}

=== Tags with parameters

Tag (with or without <>) can have dictionary parameters.

{{{
>>> e = HTMLElement("tag", {"param":"value"}) # without <>, because normal text can't have parameters
>>> print e
<tag param="value">
>>> print e.params # parameters are accessed thru .params property
{'param': 'value'}
}}}

=== Tags with content

You can create content manually:

{{{
>>> e = HTMLElement("<tag>")
>>> e.childs.append(HTMLElement("content"))
>>> e.endtag = HTMLElement("</tag>")
>>> print e
<tag>content</tag>
}}}

But there is also easier way:

{{{
>>> print HTMLElement("tag", [HTMLElement("content")])
<tag>content</tag>
}}}

or 

{{{
>>> print HTMLElement("tag", {"some":"parameter"}, [HTMLElement("content")])
<tag some="parameter">content</tag>
}}}

= Confused? =
If you don't understand how to use it, look at examples in ./examples/.
	
If you have questions, you can write me an email to: {{{bystrousak}}}{{{@kitakitsune.org}}}

